<!DOCTYPE html>
<meta charset = "UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<head>
	<title>Rays</title>
	
	<script type = "text/javascript" src = "js/lib/es6-promise.auto.min.js"></script>
	<script type = "text/javascript" src = "js/lib/tinycolor2.js"></script>
	<script type = "text/javascript" src = "js/lib/pixi.min.js"></script>
	<script type = "text/javascript" src = "js/rays.js"></script>
	<script type = "text/javascript" src = "js/load.js"></script>
	
	<link rel = "stylesheet" type = "text/css" href = "css/normalize.css">
	<link rel = "stylesheet" type = "text/css" href = "css/rays.css">
	
	<!--
	TEST TEST TEST
	-->
	
	<script id = "simple_test" type = "shader">
		varying vec2 vTextureCoord;
		
		uniform sampler2D uSampler;
		uniform vec2 dimensions;
		uniform vec2 canvas_size;
		uniform vec4 filterArea;
		uniform float px_tile_width;
		uniform float time;
		
		vec2 mapCoord( vec2 coord ) {
			coord *= filterArea.xy;
			coord += filterArea.zw;

			return coord;
		}

		vec2 unmapCoord( vec2 coord ) {
			coord -= filterArea.zw;
			coord /= filterArea.xy;

			return coord;
		}
		
		bool almost_eq(float num1, float num2, float range) {
			return (abs(num1 - num2) <= range);
		}
		
		float get_flip(vec2 fr, float prog) {
			// some constants
			float width = 0.5;
			float round = 1.0;
			float pi = 3.1415927;
			
			// begin
			vec2 uv = vec2(2.0 * fr - 1.0);
			vec3 r = vec3(uv, 3.0);
			vec3 n = vec3(0.0, sin(prog * pi), cos(prog * pi));
			float t = (r.z * n.z)/dot(n, r);
			vec3 p = r * t;
			vec2 q = vec2(p.x, p.y/n.z);
			float flipped = round - length(q - clamp(q, -width, width));
			
			return flipped;
		}
		
		
		void main(void){
			// get screen/px coord
			vec2 screen = mapCoord(vTextureCoord);
			
			// get px square coord
			vec2 raw = vec2((screen.x / px_tile_width), (screen.y / px_tile_width));
			vec2 fr = fract(raw);
			vec2 px_square_coord = vec2(floor(raw.x) * px_tile_width, floor(raw.y) * px_tile_width);
			px_square_coord += 0.5; // prevents bleeding
			
			// put it back as a texture coord and get the square color
			vec2 orig = unmapCoord(screen);
			vec2 sq_coord = unmapCoord(px_square_coord);
			vec4 sq_color = texture2D(uSampler, sq_coord);
			
			vec4 out_color = sq_color;
			
			// screen percent between 0 and 1 for scanline
			float screen_y_pct = (mapCoord(vTextureCoord) / dimensions).y;
			// duration of flip animation in percent screen height
			float flip_dur = 0.2;
			// flip_p is progress of flip between 0 and 1
			float flip_p = clamp((time - screen_y_pct) / flip_dur, 0.0, 1.0);
			
			// get border
			float modx = 0.0;
			modx = floor(mod(screen.x, px_tile_width));
			float bordx = step(1.0, modx);
			float mody = 0.0;
			mody = floor(mod(screen.y, px_tile_width));
			float bordy = step(1.0, mody);
			
			// call flip here
			float flipped = get_flip(fr, flip_p);
			
			float border = bordx * bordy;
			
			//flipped = clamp(flipped, 0.5, 1.0);
			out_color = out_color * flipped;
			
			gl_FragColor = vec4(out_color.r, out_color.g, out_color.b, 1.0);
		}
	</script>
	
	<script id = "scanline_test" type = "shader">
		varying vec2 vTextureCoord;
		uniform vec4 filterArea;
		uniform vec2 dimensions;
		uniform sampler2D uSampler;
		uniform float time;
		
		vec2 mapCoord( vec2 coord ) {
			coord *= filterArea.xy;
			coord += filterArea.zw;

			return coord;
		}

		vec2 unmapCoord( vec2 coord ) {
			coord -= filterArea.zw;
			coord /= filterArea.xy;

			return coord;
		}
		
		bool almost_eq(float num1, float num2, float range) {
			return (abs(num1 - num2) <= range);
		}
		
		void main(void) {
			vec2 coord = mapCoord(vTextureCoord) / dimensions;
			//coord = unmapCoord(coord);
			
			
			
			// 1 pixel's worth of .y
			float range = 1.0 / dimensions.y;
			float indicator = 0.0;
			if (almost_eq(coord.y, time, range)) {
				indicator = 1.0;
			}
			
			// interval after time when something else should happen
			float interval = 0.2;
			float after_indicator = 0.0;
			if (almost_eq(coord.y, time - interval, range)) {
				after_indicator = 1.0;
			}
			
			vec4 color = texture2D(uSampler, coord);
			gl_FragColor = vec4(color.r, indicator, after_indicator, 1.0);
		}
	</script>
	
	<script id = "compare_test" type = "shader">
		varying vec2 vTextureCoord;
		uniform sampler2D last_frame;
		uniform vec4 filterArea;
		uniform vec2 dimensions;
		
		vec2 mapCoord( vec2 coord ) {
			coord *= filterArea.xy;
			coord += filterArea.zw;

			return coord;
		}

		vec2 unmapCoord( vec2 coord ) {
			coord -= filterArea.zw;
			coord /= filterArea.xy;

			return coord;
		}
		
		void main(void) {
			
			// this works but has that weird offset
			//vec2 coord = (mapCoord(vTextureCoord) - filterArea.zw) / dimensions;
			vec2 other_dim = vec2 (1024.0, 768.0);
			vec2 coord = ((vTextureCoord * filterArea.xy) + filterArea.zw) / other_dim;
			gl_FragColor = texture2D(last_frame, coord);
			
		}
		
	</script>
	
	<script id = "step_trans_shader" type = "shader">
		varying vec2 vTextureCoord;
		
		uniform sampler2D uSampler;
		uniform sampler2D tile_tex0;
		uniform sampler2D tile_tex1;
		uniform sampler2D tile_tex2;
		uniform sampler2D tile_tex3;
		uniform sampler2D last_frame;
		uniform float tile_tex_ratio_x;
		uniform float tile_tex_ratio_y;
		uniform vec2 dimensions;
		uniform vec2 canvas_size;
		uniform vec2 unif_last_frame_dim;
		uniform vec4 filterArea;
		uniform float px_tile_width;
		uniform float time;
		
		
		vec2 mapCoord( vec2 coord ) {
			coord *= filterArea.xy;
			coord += filterArea.zw;

			return coord;
		}

		vec2 unmapCoord( vec2 coord ) {
			coord -= filterArea.zw;
			coord /= filterArea.xy;

			return coord;
		}
		
		bool almost_eq(float num1, float num2, float range) {
			return (abs(num1 - num2) <= range);
		}
		
		float get_flip(vec2 fr, float prog) {
			// some constants
			float width = 0.5;
			float round = 0.8;
			float pi = 3.1415927;
			
			// begin
			vec2 uv = vec2(2.0 * fr - 1.0);
			vec3 r = vec3(uv, 3.0);
			vec3 n = vec3(0.0, sin(prog * pi), cos(prog * pi));
			float t = (r.z * n.z)/dot(n, r);
			vec3 p = r * t;
			vec2 q = vec2(p.x, p.y/n.z);
			float flipped = round - length(q - clamp(q, -width, width));
			
			return flipped * ((1.0 / round) + 0.1);
		}
		
		void main(void){
			// get screen/px coord
			vec2 screen = mapCoord(vTextureCoord);
			
			// get px square coord
			vec2 raw = vec2((screen.x / px_tile_width), (screen.y / px_tile_width));
			vec2 fr = fract(raw);
			vec2 px_square_coord = vec2(floor(raw.x) * px_tile_width, floor(raw.y) * px_tile_width);
			px_square_coord += 0.5; // prevents bleeding
			
			// put it back as a texture coord and get the square color
			vec2 orig = unmapCoord(screen);
			vec2 sq_coord = unmapCoord(px_square_coord);
			vec4 sq_color = texture2D(uSampler, sq_coord);
			
			// pseudo-frame difference indicator
			float indicator = 0.0;
			
			// now get the square color of the next pseudo-frame
			vec2 last_frame_dim = vec2(1024.0, 768.0);
			vec2 next_sq_coord = ((sq_coord * filterArea.xy) + filterArea.zw) / last_frame_dim; // works!
			vec4 last_sq_color = texture2D(last_frame, next_sq_coord);
			
			
			// step colors
			float num_colors = 6.0;
			sq_color = floor(sq_color * num_colors) / num_colors;
			last_sq_color = floor(last_sq_color * num_colors) / num_colors;
			
			// get the difference between the square colors
			vec4 color_diff = abs(sq_color - last_sq_color);
			// if this pseudo-frame's tile should be different than the last, set indicator
			if (color_diff.r > 0.1) {
				indicator = 1.0;
			}
			
			// get the various tile colors
			vec2 tile_tex_ratio = vec2(tile_tex_ratio_x, tile_tex_ratio_y);
			vec4 tile_tex0_color = texture2D(tile_tex0, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex1_color = texture2D(tile_tex1, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex2_color = texture2D(tile_tex2, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex3_color = texture2D(tile_tex3, vTextureCoord * tile_tex_ratio);
			
			vec4 out_color;
			vec4 cur_frame_color;
			vec4 last_frame_color;
			
			// set the current frame's tile color
			if (sq_color.r < 0.1) {
				cur_frame_color = tile_tex0_color;
			}
			else if (sq_color.r < 0.3) {
				cur_frame_color = tile_tex1_color;
			}
			else if (sq_color.r < 0.6) {
				cur_frame_color = tile_tex2_color;
			}
			else {
				cur_frame_color = tile_tex3_color;
			}
			
			// now the last frame's tile color
			if (last_sq_color.r < 0.1) {
				last_frame_color = tile_tex0_color;
			}
			else if (last_sq_color.r < 0.3) {
				last_frame_color = tile_tex1_color;
			}
			else if (last_sq_color.r < 0.6) {
				last_frame_color = tile_tex2_color;
			}
			else {
				last_frame_color = tile_tex3_color;
			}
			
			// pick which color we're using based on diff indicator
			if (indicator == 1.0) {
				out_color = last_frame_color;
			}
			else if (indicator == 0.0) {
				out_color = cur_frame_color;
			}
			
			// adds some randomness to the flip phase
			float flip_phase_offset = texture2D(tile_tex1, sq_coord * tile_tex_ratio).r;
			
			// screen percent between 0 and 1 for scanline
			float screen_y_pct = (mapCoord(vTextureCoord) / dimensions).y;
			// duration of flip animation in percent screen height, used only with scanline
			float flip_dur = 0.5;
			// flip_p is progress of flip between 0 and 1
			float flip_p;
			// flip_p = clamp((time - screen_y_pct) / flip_dur, 0.0, 1.0); // use for scanline effect
			flip_p = time + flip_phase_offset; // use to flip all tiles at once, no scanline
			
			if (indicator == 0.0) {
				flip_p = 0.0;
			}
			
			// get border
			float modx = 0.0;
			modx = floor(mod(screen.x, px_tile_width));
			float bordx = step(1.0, modx);
			float mody = 0.0;
			mody = floor(mod(screen.y, px_tile_width));
			float height_in_tile = (mody / px_tile_width);
			float bordy = step(1.0, mody);
			//float flipped = step(flip_p, height_in_tile);
			float border = bordx * bordy;
			
			float tile_shape = get_flip(fr, flip_p);
			//tile_shape = clamp(tile_shape, tile_tex0_color.b, 1.0);
			//tile_shape = clamp(tile_shape, 0.25, 1.0);
			
			// sets flip color if border was set to vec2(0,0) but we're not actually on a border
			if (mody > 0.01 && modx > 0.01 && tile_shape < 0.01) {
				border = 1.0;
				out_color = cur_frame_color;
			}
			
			// pick tile output color by checking that we're more than halfway through the flip
			out_color = mix(cur_frame_color, last_frame_color, step(flip_p, 0.5)) * tile_shape;
			
			border = 1.0;//clamp(border, 0.3, 1.0);
			
			gl_FragColor = vec4(out_color.r * border , out_color.g * border, out_color.b * border, 1.0);
		}
	</script>
	
	<script id = "shader" type = "shader">
		varying vec2 vTextureCoord;
		
		uniform sampler2D uSampler;
		uniform sampler2D tile_tex0;
		uniform sampler2D tile_tex1;
		uniform sampler2D tile_tex2;
		uniform sampler2D tile_tex3;
		uniform float tile_tex_ratio_x;
		uniform float tile_tex_ratio_y;
		uniform vec2 dimensions;
		uniform vec4 filterArea;
		uniform float px_tile_width;
		
		
		vec2 mapCoord( vec2 coord ) {
			coord *= filterArea.xy;
			coord += filterArea.zw;

			return coord;
		}

		vec2 unmapCoord( vec2 coord ) {
			coord -= filterArea.zw;
			coord /= filterArea.xy;

			return coord;
		}
		
		float get_flip(vec2 fr, float prog) {
			// some constants
			float width = 0.5;
			float round = 0.8;
			float pi = 3.1415927;
			
			// begin
			vec2 uv = vec2(2.0 * fr - 1.0);
			vec3 r = vec3(uv, 3.0);
			vec3 n = vec3(0.0, sin(prog * pi), cos(prog * pi));
			float t = (r.z * n.z)/dot(n, r);
			vec3 p = r * t;
			vec2 q = vec2(p.x, p.y/n.z);
			float flipped = round - length(q - clamp(q, -width, width));
			
			return flipped * ((1.0 / round) + 0.1);
			//return flipped;
		}
		
		void main(void){
			// get screen/px coord
			vec2 screen = mapCoord(vTextureCoord);
			
			// TEST
			//vec2 coord = mapCoord(vTextureCoord) / dimensions;
			//vec2 screen = mapCoord(coord);
			
			// get px square coord
			vec2 raw = vec2((screen.x / px_tile_width), (screen.y / px_tile_width));
			vec2 fr = fract(raw);
			vec2 px_square_coord = vec2(floor(raw.x) * px_tile_width, floor(raw.y) * px_tile_width);
			px_square_coord += 0.5; // prevents bleeding
			
			// put it back as a texture coord and get the square color
			vec2 orig = unmapCoord(screen);
			vec2 sq_coord = unmapCoord(px_square_coord);
			vec4 sq_color = texture2D(uSampler, sq_coord);
			
			// step colors
			float num_colors = 6.0;
			sq_color = floor(sq_color * num_colors) / num_colors;
			
			// get the various 
			vec2 tile_tex_ratio = vec2(tile_tex_ratio_x, tile_tex_ratio_y);
			vec4 tile_tex0_color = texture2D(tile_tex0, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex1_color = texture2D(tile_tex1, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex2_color = texture2D(tile_tex2, vTextureCoord * tile_tex_ratio);
			vec4 tile_tex3_color = texture2D(tile_tex3, vTextureCoord * tile_tex_ratio);
			
			vec4 out_color;
			if (sq_color.r < 0.1) {
				out_color = tile_tex0_color;
			}
			else if (sq_color.r < 0.3) {
				out_color = tile_tex1_color;
			}
			else if (sq_color.r < 0.6) {
				out_color = tile_tex2_color;
			}
			else {
				out_color = tile_tex3_color;
			}
			
			
			// get border
			float modx = 0.0;
			modx = floor(mod(screen.x, px_tile_width));
			float bordx = step(1.0, modx);
			float mody = 0.0;
			mody = floor(mod(screen.y, px_tile_width));
			float bordy = step(1.0, mody); 
			float border = bordx * bordy;
			
			float tile_shape = get_flip(fr, 0.0);
			out_color = out_color * tile_shape;
			
			border = 1.0;//clamp(border, 0.3, 1.0);
			
			gl_FragColor = vec4(out_color.r * border , out_color.g * border, out_color.b * border, 1.0);
			//gl_FragColor = vec4(0.0, fr[0], 0.0, 1.0);
		}
	</script>
	
	
	
	
</head>

<html>
<body onload = "rays_app.run()">
	<header class = "page-head">
		<h2>Ray Casting</h2>
	</header>
	<div class = "wrapper">
		<header>
			<h3>FPS: <span id = "fps_field"></span></h3>
			<div id = "rays_controls_container"></div>
		</header>
		
		<div class = "canvas-container">
			<canvas id = "main_canvas" class = "" width = "1024" height = "768"></canvas>
			<div class = "map-container">
				<canvas id = "map_bg_canvas" class = "map-canvas bg" width = "600px" height = "600px"></canvas
				><canvas id = "map_canvas" class = "map-canvas fg" width = "600px" height = "600px"></canvas>
			</div>
		</div>
		
	</div>
</body>
</html>